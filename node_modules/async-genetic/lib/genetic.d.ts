export declare const Select: {
    Tournament2: typeof Tournament2;
    Tournament3: typeof Tournament3;
    Fittest: typeof Fittest;
    Random: typeof Random;
    RandomLinearRank: typeof RandomLinearRank;
    Sequential: typeof Sequential;
};
export interface GeneticOptions<T> {
    mutationFunction: (phenotype: T) => T;
    crossoverFunction: (a: T, b: T) => Array<T>;
    fitnessFunction: (phenotype: T) => Promise<number>;
    randomFunction: () => T;
    populationSize: number;
    mutateProbablity?: number;
    crossoverProbablity?: number;
    fittestNSurvives?: number;
    select1?: (pop: any) => T;
    select2?: (pop: any) => T;
    optimize?: (scoreA: number, scoreB: number) => boolean;
}
export interface Phenotype<T> {
    fitness: number;
    entity: T;
}
export declare class Genetic<T> {
    private entities;
    stats: {};
    options: GeneticOptions<T>;
    protected internalGenState: {};
    private population;
    constructor(options: GeneticOptions<T>, entities?: Array<T>);
    seed(entities?: Array<T>): void;
    best(count?: number): T[];
    breed(): void;
    estimate(): Promise<void>;
    private tryCrossover;
    private tryMutate;
    /**
     * Mean deviation
     */
    private getMean;
    /**
     * Standart deviation
     */
    private getStdev;
    private selectOne;
    private selectPair;
}
/** Utility */
declare function Tournament2<T>(this: Genetic<T>, pop: any): any;
declare function Tournament3<T>(this: Genetic<T>, pop: Array<Phenotype<T>>): T;
declare function Fittest<T>(this: Genetic<T>, pop: Array<Phenotype<T>>): T;
declare function Random<T>(this: Genetic<T>, pop: Array<Phenotype<T>>): T;
declare function RandomLinearRank<T>(this: Genetic<T>, pop: Array<Phenotype<T>>): T;
declare function Sequential<T>(this: Genetic<T>, pop: Array<Phenotype<T>>): T;
export {};
